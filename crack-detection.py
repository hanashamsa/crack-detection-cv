# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L7QT-x_vp1iFuKqIh0_SLg0szaq5aZKN
"""

# Import all packages needed in this notebook.

import numpy as np
import cv2 as cv
from PIL import Image
from matplotlib import pyplot as plt
from torchvision.models.resnet import resnet152
from torchvision.models.vgg import vgg19
from torchvision.models import VGG19_Weights, ResNet152_Weights
from torchvision.transforms import functional as F
import torch
import os
import glob
from sklearn.model_selection import train_test_split
import shutil

def read_Img_Torch(input_img, using_Cuda :bool = False):

    if type(input_img) != str:
        raise ValueError("input must be string)")

    img_Orig = Image.open(input_img)
    image_np = np.array(img_Orig)/255.0

    if image_np.ndim != 3:
        raise ValueError("input image must have 3 channels)")
    image_np = np.transpose(image_np, (2, 0, 1))

    if using_Cuda:
        return torch.tensor(image_np, dtype=torch.float32).cuda().unsqueeze(0).float()
    else:
        return torch.tensor(image_np, dtype=torch.float32).unsqueeze(0).float()

# After uploading the image, update the path below to the correct location
img_input = read_Img_Torch("/content/resources/resources/Example_Crack.JPG")

print(img_input.shape)
F.to_pil_image(img_input[0])

pip install ultralytics

from ultralytics import YOLO
model = YOLO('yolov8n-seg.pt')  # load a pretrained model

random_state = 123


images_path = '/content/resources/resources/crack-seg-A2/images'
labels_path = '/content/resources/resources/crack-seg-A2/labels'


image_files = sorted(glob.glob(os.path.join(images_path, '*.jpg')))
label_files = sorted(glob.glob(os.path.join(labels_path, '*.txt')))


assert len(image_files) == len(label_files), "Mismatch between images and labels!"


train_val_images, test_images, train_val_labels, test_labels = train_test_split(
    image_files, label_files, test_size=0.05, random_state=random_state
)


train_images, val_images, train_labels, val_labels = train_test_split(
    train_val_images, train_val_labels, test_size=0.15 / 0.95, random_state=random_state
)


print(f"Total images: {len(image_files)}")
print(f"Train: {len(train_images)}, Validation: {len(val_images)}, Test: {len(test_images)}")


output_path = 'resources/splits'
os.makedirs(output_path, exist_ok=True)


with open(os.path.join(output_path, 'train_images.txt'), 'w') as f:
    f.writelines('\n'.join(train_images) + '\n')

with open(os.path.join(output_path, 'val_images.txt'), 'w') as f:
    f.writelines('\n'.join(val_images) + '\n')

with open(os.path.join(output_path, 'test_images.txt'), 'w') as f:
    f.writelines('\n'.join(test_images) + '\n')

with open(os.path.join(output_path, 'train_labels.txt'), 'w') as f:
    f.writelines('\n'.join(train_labels) + '\n')

with open(os.path.join(output_path, 'val_labels.txt'), 'w') as f:
    f.writelines('\n'.join(val_labels) + '\n')

with open(os.path.join(output_path, 'test_labels.txt'), 'w') as f:
    f.writelines('\n'.join(test_labels) + '\n')

def create_folders():
    if not os.path.exists('resources/resources/data_seg_A2'): os.mkdir('resources/resources/data_seg_A2')
    if not os.path.exists('resources/resources/data_seg_A2/test'): os.mkdir('resources/resources/data_seg_A2/test')
    if not os.path.exists('resources/resources/data_seg_A2/train'): os.mkdir('resources/resources/data_seg_A2/train')
    if not os.path.exists('resources/resources/data_seg_A2/valid'): os.mkdir('resources/resources/data_seg_A2/valid')

    # images
    if not os.path.exists('resources/resources/data_seg_A2/test/images'): os.mkdir('resources/resources/data_seg_A2/test/images')
    if not os.path.exists('resources/resources/data_seg_A2/train/images'): os.mkdir('resources/resources/data_seg_A2/train/images')
    if not os.path.exists('resources/resources/data_seg_A2/valid/images'): os.mkdir('resources/resources/data_seg_A2/valid/images')

    # labels
    if not os.path.exists('resources/resources/data_seg_A2/test/labels'): os.mkdir('resources/resources/data_seg_A2/test/labels')
    if not os.path.exists('resources/resources/data_seg_A2/train/labels'): os.mkdir('resources/resources/data_seg_A2/train/labels')
    if not os.path.exists('resources/resources/data_seg_A2/valid/labels'): os.mkdir('resources/resources/data_seg_A2/valid/labels')

def copy_img_label(image_files, label_files, type_file : str):
    create_folders()

    if type_file.lower() == 'test':
        for img_files, lab_files in zip (image_files, label_files):
            shutil.copy2(img_files, 'resources/resources/data_seg_A2/test/images/')
            shutil.copy2(lab_files, 'resources/resources/data_seg_A2/test/labels/')

    elif type_file.lower() == 'train':
        for img_files, lab_files in zip (image_files, label_files):
            shutil.copy2(img_files, 'resources/resources/data_seg_A2/train/images/')
            shutil.copy2(lab_files, 'resources/resources/data_seg_A2/train/labels/')

    elif type_file.lower() == 'valid':
        for img_files, lab_files in zip (image_files, label_files):
            shutil.copy2(img_files, 'resources/resources/data_seg_A2/valid/images/')
            shutil.copy2(lab_files, 'resources/resources/data_seg_A2/valid/labels/')
    else:
        raise ValueError("The string should be 'test', 'train', 'valid'")

images_path = 'resources/resources/crack-seg-A2/images'
labels_path = 'resources/resources/crack-seg-A2/labels'


all_images = sorted(glob.glob(os.path.join(images_path, '*.jpg')))
all_labels = sorted(glob.glob(os.path.join(labels_path, '*.txt')))


train_images, train_labels = all_images[:3222], all_labels[:3222]
val_images, val_labels = all_images[3222:3827], all_labels[3222:3827]
test_images, test_labels = all_images[3827:], all_labels[3827:]


copy_img_label(train_images, train_labels, 'train')
copy_img_label(val_images, val_labels, 'valid')
copy_img_label(test_images, test_labels, 'test')

print("All subsets have been successfully saved in their respective folders.")

model.train(
    data='/content/resources/resources/data_A2.yaml',
    epochs=10,
    batch=16,
    imgsz=320,
    seed=123
)

metrics = model.val(data='/content/resources/resources/data_A2.yaml', imgsz=320)
print(metrics)

# The code goes here
test_images_path = 'resources/resources/data_seg_A2/test/images'

all_test_images = sorted(glob.glob(os.path.join(test_images_path, '*.jpg')))
if len(all_test_images) == 0:
    raise FileNotFoundError(f"No test images found in {test_images_path}")


test_images_to_predict = all_test_images[:20]


model.predict(
    source=test_images_to_predict,
    conf=0.1,
    save=True
)


print("Predicted results are saved in 'runs/segment/predict'")

# The code goes here
import cv2

predict_folder = 'runs/segment/train5'
predicted_images = sorted(glob.glob(os.path.join(predict_folder, "*.jpg")))


if not predicted_images:
    raise FileNotFoundError(f"No images found in the folder: {predict_folder}")


images_to_show = predicted_images[:8]


fig, axes = plt.subplots(2, 4, figsize=(12, 6))
axes = axes.ravel()

for i, img_path in enumerate(images_to_show):
    img = cv2.imread(img_path)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    axes[i].imshow(img)
    axes[i].axis("off")
    axes[i].set_title(f"Image {i+1}")



plt.show()

